## 事件流和两个阶段


事件流指的是事件完成执行过程中的流动路径
简单来说：捕获阶段是从父到子， 冒泡阶段是从子到父
实际工作都是使用事件冒泡为主


GPT解释：

当然可以。让我们详细地了解事件流和其在DOM中的行为。

### 1. 什么是事件流？

事件流描述了当一个事件发生时，它是如何在DOM结构中传播的过程。这包括事件是如何从根节点传递到目标元素，以及从目标元素回传到根节点的过程。

### 2. 事件流的三个阶段：

#### 2.1 事件捕获阶段 (Capturing Phase)

这是事件流的第一个阶段。当一个事件发生时，浏览器首先会检查最外层的元素（通常是 `document` 对象或 `window` 对象），然后逐级向下，直到到达触发事件的目标元素。这个阶段是从外到内的。

#### 2.2 目标阶段 (Target Phase)

在这个阶段，事件已经到达实际触发事件的目标元素。在这里，任何绑定到目标元素的事件处理函数都会被触发。

#### 2.3 事件冒泡阶段 (Bubbling Phase)

事件开始从目标元素向上冒泡，经过其所有的父元素，直到再次到达最外层的元素。这个阶段是从内到外的。

### 3. 事件类型

当我们说到“事件”，我们实际上是指特定的事件类型，如 `click`、`mousedown`、`keyup` 等。每种事件类型在DOM中都有其自己独特的事件流。例如，一个 `click` 事件和一个 `mousedown` 事件，尽管可能在同一元素上同时发生，但它们在DOM中的传播路径是独立的。

### 4. 注册事件处理器

当我们使用 `addEventListener` 方法注册事件处理器时，我们可以选择在哪个阶段执行这个处理器：捕获阶段还是冒泡阶段。这是通过 `addEventListener` 的第三个参数来决定的。如果设置为 `true`，则处理器在捕获阶段执行；如果设置为 `false` 或省略，则在冒泡阶段执行。

### 5. 为什么要了解事件流？

理解事件流对于高效地使用事件处理和避免潜在的问题非常重要。例如，如果你想在多个嵌套的元素上都有事件处理器，并且想阻止某些事件传播，了解事件流将帮助你更准确地控制这些行为。

希望这个解释帮助你更深入地理解了事件流及其在DOM中的行为。




## 事件捕获

概念：
从DOM的根元素开始去执行对应的事件（从外到里）

- 事件捕获需要写对应代码才能看到效果
  
代码：
```js
DOM.addEventListerner(事件类型, 事件处理函数, 是否使用捕获机制)
```
- 说明：1. addEventListener第三个参数传入true代表是捕获阶段触发（很少使用）
- 若传入false代表冒泡阶段触发，默认参数就是false
- 若是用L0事件监听，则只有冒泡阶段，没有捕获


## 事件冒泡（重点）

事件冒泡概念：

- 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发，这一过程称为事件冒泡
- 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的**同名事件**
- 事件冒泡是默认存在的
- L2事件监听第三个参数是false，或者默认都是冒泡


GPT解释：
当事件在 DOM 中发生时，它会经历两个主要阶段：事件捕获和事件冒泡。这两个阶段构成了所谓的事件流。以下是这两个阶段的详细介绍：

1. **事件捕获（Event Capturing）**
    - 当事件发生时，浏览器首先检查文档的最外层元素（通常是 `document` 对象）是否有任何监听该事件的处理程序，并在捕获阶段执行它们。
    - 接着，浏览器沿 DOM 树向下移动，检查事件目标的每个祖先元素是否有注册的事件监听器。
    - 这个过程持续到达达到实际触发事件的元素，但在目标阶段之前会停止。

2. **事件冒泡（Event Bubbling）**
    - 一旦事件到达其目标元素，并且在目标元素上进行了任何必要的处理，它就开始从目标元素向上“冒泡”。
    - 这意味着事件会沿着 DOM 树向上移动，检查每个祖先元素是否有注册的事件监听器，如果有，就执行它们。
    - 冒泡过程继续直到到达文档的最外层，通常是 `document` 对象。

这两个阶段提供了在事件传播过程的不同点捕获或处理事件的能力。例如，使用 `addEventListener` 方法添加事件处理程序时，可以选择在哪个阶段处理事件：

- 在事件捕获阶段处理事件，可以设置 `addEventListener` 的第三个参数为 `true`。
- 在事件冒泡阶段处理事件，可以设置第三个参数为 `false` 或简单地省略它。

了解事件捕获和事件冒泡的区别和工作机制，对于理解和利用事件流是非常重要的。这使得开发者能够决定在哪个阶段对事件进行处理，以及如何优化事件处理策略（例如，通过事件委托）。

## 阻止冒泡

问题： 因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素
需求： 若想把事件就限制在当前元素内，就需要阻止事件冒泡
前提： 阻止事件冒泡需要拿到事件对象
语法： 
```js
事件对象.stopPropagation()
```

注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效。

## 阻止默认行为

在JavaScript中，当某些事件触发时，它们具有默认的行为。例如，当你点击一个链接时，浏览器的默认行为是导航到该链接的地址；当你提交一个表单时，浏览器的默认行为是发送请求到服务器。

但有时候，你可能希望阻止这些默认行为，特别是当你希望用JavaScript为元素添加自定义行为时。你可以使用事件对象的 `preventDefault()` 方法来实现这一点。

以下是一些常见的使用场景：

1. **阻止链接跳转**:
    ```javascript
    document.querySelector('a').addEventListener('click', function(e) {
        e.preventDefault();
        // 你的自定义行为
    });
    ```

2. **阻止表单提交**:
    ```javascript
    document.querySelector('form').addEventListener('submit', function(e) {
        e.preventDefault();
        // 你的自定义行为
    });
    ```

3. **阻止右键菜单** (例如，当你希望为元素添加自定义的右键菜单时):
    ```javascript
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        // 显示你的自定义菜单
    });
    ```

在上述示例中，`e` 是传递给事件处理程序的事件对象。调用 `e.preventDefault()` 将阻止事件的默认行为。但要注意，不是所有的事件都有默认行为，所以 `preventDefault()` 不适用于所有事件。