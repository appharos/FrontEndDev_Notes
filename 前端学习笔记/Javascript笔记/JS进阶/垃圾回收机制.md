## 垃圾回收机制



内存的生命周期：

JS环境中分配的内存，一般有如下生命周期：

1. 内存分配; 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存


说明： 
- 全局变量一般不会回收（关闭页面回收）
- 一般情况下局部变量的值，不用了，会被自动回收掉

内存泄露： 程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏


JS垃圾回收机制-算法说明

堆栈空间分配区别：
1. 栈（操作系统）：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
2. 堆（操作系统）：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。
   

   


ChatGPT解释：

内存的生命机制

JS环境中分配的内存，一般有如下生命周期：


JavaScript的垃圾回收（Garbage Collection，简称GC）机制是自动的，它帮助开发者管理内存，防止内存泄露。垃圾回收器会定期寻找那些不再使用的变量或对象，并释放其占用的内存。主要的垃圾回收算法包括：

### 1. 引用计数垃圾收集（Reference Counting）

这是最初级的垃圾回收机制。当一个对象的引用次数变为0时，说明没有任何地方使用这个对象了，垃圾收集器就会回收其占用的内存。但是，这种方式有一个明显的缺陷，即无法处理循环引用的情况。

**循环引用的情况**

引用计数垃圾收集是一种简单直观的内存管理技术。每个对象都有一个与之关联的引用计数器，每当有一个新的引用指向该对象时，引用计数就增加；相应地，当引用失效时，引用计数减少。一旦一个对象的引用计数降到零，意味着没有任何活动引用指向该对象，垃圾收集器就可以释放该对象所占用的内存。

然而，引用计数方法存在一个主要缺陷：无法处理循环引用的情况。如果两个或多个对象相互引用，即使它们已经不再被其他活动部分的代码所引用，它们的引用计数也永远不会达到零。因此，这些相互引用的对象不会被视为垃圾，导致内存泄露。

### 循环引用的例子

举个例子来说明循环引用：

```javascript
function problem() {
  var objectA = {};
  var objectB = {};
  
  objectA.reference = objectB;
  objectB.reference = objectA;
}

problem();
```

在这个例子中，`objectA` 和 `objectB` 分别有一个属性指向对方，创建了一个循环引用。即便函数 `problem()` 的执行完成后，理论上 `objectA` 和 `objectB` 都已经不再被需要了，但是它们的引用计数都是1，因为它们互相引用着对方。因此，如果一个垃圾回收器只使用引用计数策略，这两个对象都不会被回收，从而导致内存泄露。

### 解决循环引用

现代JavaScript引擎使用标记-清除或其他更高级的垃圾收集算法，这些算法能够处理循环引用的问题。当对象不再从根（全局变量或活跃的函数的局部变量等）可达时，即使它们相互引用，也会被垃圾收集器清除。

在使用引用计数的环境（如某些旧的浏览器或JavaScript以外的环境），开发者需要手动解决循环引用问题，比如在对象不再需要时，将它们的属性设置为 `null`，打断循环引用：

```javascript
objectA.reference = null;
objectB.reference = null;
```

通过这种方式，引用计数降至零，这两个对象就可以被垃圾收集器回收了。在现代JavaScript环境中，这种手动解引用通常是不必要的，因为现代垃圾回收机制已经能够很好地处理循环引用。


### 2. 标记-清除（Mark and Sweep）

这是当前大多数JavaScript垃圾回收器采用的算法。工作原理如下：

- **标记阶段**：垃圾回收器从根（通常是全局对象）开始，找到所有从根开始引用的对象，再找到这些对象引用的对象，依此类推。在这个过程中遇到的对象都会被标记为“活动”的。
- **清除阶段**：垃圾回收器再次扫描内存中的对象，那些在标记阶段没有被标记为“活动”的对象就会被视为“垃圾”并进行回收。

### 3. 增量收集（Incremental Collection）

由于标记-清除算法需要停止程序执行来进行垃圾回收，这可能会导致停顿（jank）。为了改善响应性，增量收集算法将垃圾回收分成小片段，分散到程序执行的各个部分中去。

### 4. 分代收集（Generational Collection）

大多数垃圾回收器会基于对象的存活时间将内存分为几个“代”。通常情况下，新生代（young generation）中的对象是那些存活时间短的对象，而老年代（old generation）中的对象是存活时间长的。这样可以针对不同的对象应用不同的垃圾回收策略，以提高效率。

### 5. 标记-整理（Mark-Compact）

为了解决碎片化的问题，一些垃圾收集器会在标记死亡对象后，将存活的对象移动到内存的一端，从而减少碎片化，使得新分配的大对象更容易找到连续的空间。



### 垃圾回收的触发

垃圾回收可以被以下几种情况触发：

- 内存使用达到一定的阈值。
- 执行栈大小的改变（如函数调用结束时）。  
- 资源管理API的调用（如`window.requestIdleCallback()`在浏览器中）。

### 开发者的考虑

虽然垃圾回收是自动的，但开发者仍然需要采取一些最佳实践来优化内存使用：

- 尽量减少全局变量的使用。
- 使用局部变量，这样它们可以在不需要时被回收。
- 注意闭包的使用，因为闭包可能会阻止垃圾回收。
- 避免循环引用，尤其是在使用DOM元素时。

通过这些方法，可以帮助垃圾回收器更有效地工作，从而提高程序的性能和响应性。