## 原型链

基于原型对象的继承使得不同构造函数的原型对象关联在一起,并且这种关联的关系是一种链状的结构,我们将原型对象的链状结构关系称为原型链

## 查找规则

1) 当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性
2) 如果没有就查找它的原型(也就是__protp__指向的prototype原型对象)
3) 入宫还没有就查找原型对象的原型(Object的原型对象)
4) 以此类推一直找到Obejct为止(null)
5) __proto__对象原型的意义就在于为对象成员查找机制提供一个方向,或者说一个路线
6) 可以使用instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上

GPT解释:

### 原型链

在 JavaScript 中，原型链是实现继承的主要方式。原型链建立在原型对象（prototype）的概念上。每个 JavaScript 对象都有一个链接到另一个对象的内部链接，称为原型。这个链接到的对象也有自己的原型，以此类推，形成一个“原型链”。

#### 工作原理

- 当尝试访问一个对象的属性或方法时，首先在该对象本身上搜索。
- 如果没有找到，并且该对象有原型（`__proto__` 属性），搜索会继续到原型上。
- 这个过程会沿着原型链一直向上进行，直到找到相应的属性或方法，或者到达原型链的终点（`Object.prototype` 的原型是 `null`）。

#### 示例

```javascript
function Animal() {
    this.type = 'animal';
}

Animal.prototype.speak = function() {
    console.log('Some sound');
};

function Dog() {
    Animal.call(this);
    this.type = 'dog';
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const myDog = new Dog();

console.log(myDog.speak()); // Some sound
console.log(myDog.type); // dog
```

在这个例子中，`myDog` 的原型是 `Dog.prototype`，而 `Dog.prototype` 的原型是 `Animal.prototype`。所以 `myDog` 可以访问 `Animal.prototype` 上定义的 `speak` 方法。

### `instanceof` 运算符

`instanceof` 运算符用于检测构造函数的原型是否存在于某个实例对象的原型链上。

#### 语法

```javascript
object instanceof constructor
```

- `object`：要检测的对象。
- `constructor`：某个构造函数。

#### 示例

```javascript
console.log(myDog instanceof Dog); // true
console.log(myDog instanceof Animal); // true
console.log(myDog instanceof Object); // true
```

在这个例子中，`myDog` 是 `Dog` 和 `Animal` 的实例，因为 `Dog.prototype` 是 `Animal.prototype` 的实例，而 `Animal.prototype` 又是 `Object.prototype` 的实例。

#### 工作原理

- `instanceof` 检查右侧构造函数的原型是否存在于左侧对象的原型链上。
- 如果找到相应的原型，则返回 `true`；否则返回 `false`。

#### 注意点

- `instanceof` 仅检查原型链，它不关心对象是如何创建的，只关心原型链上是否存在对应的构造函数的原型。

### 总结

原型链是 JavaScript 中实现对象间继承的机制，允许对象共享另一个对象的属性和方法。而 `instanceof` 运算符则提供了一种检测对象是否是某个构造函数的实例的方法，通过检查原型链来实现。
