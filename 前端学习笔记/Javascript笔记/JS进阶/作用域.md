## 作用域

### 局部作用域

局部作用域分为函数作用域和块作用域

1. 函数作用域
在函数内部声明的变量只能在函数内部被访问，外部无法直接进行访问

```html
    <script>
        function getSum(){
            // 函数内部都是函数作用域  属于局部变量
            const num = 10
        }

        console.log(num);    //此处报错，函数外部不能使用局部作用域变量
    </script>
```

总结：

1) 函数内部声明的变量，在函数外部无法被访问
2) 函数的参数也是函数内部的局部变量
3) 不同函数内部声明的变量无法互相访问
4) 函数执行完毕后，函数内部的变量实际被清空了

2. 块作用域：
在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问   （有可能是使用var声明变量，变量从而具有函数作用域）

```js
        for (let i = 0; i <= 3; i++) {
            console.log(i)   //正常访问
        }

        console.log(i)   //超出i的作用域，无法被访问
```

1) let 声明的变量会产生块作用域，var不会产生块作用域
2) const 声明的常量也会产生块作用域
3) 不同代码块之间的变量无法互相访问
4) 推荐使用let 或 const

### 全局作用域

script标签和.js文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问

全局作用域中声明的变量，任何其他作用域都可以被访问

在JavaScript中，全局作用域指的是代码中任何地方都能访问的区域。如果一个变量或函数是在最外层定义的，那么它就是全局的，可以在代码中的任何其他作用域内被访问和修改。

### 特点

- **全局变量**：在全局作用域中声明的变量被称为全局变量。
- **全局函数**：在全局作用域中声明的函数被称为全局函数。
- **可访问性**：全局变量和函数可以在脚本的任何地方被访问。
- **污染问题**：全局变量很容易引起命名冲突，可能会导致意料之外的变量覆盖问题，这通常被称为“全局污染”。
- **生命周期**：全局变量从被声明开始到页面被关闭之前，都一直存在，这意味着它们的生命周期很长。

### 示例

```javascript
var globalVar = "This is a global variable";

function globalFunction() {
  console.log("This is a global function");
}

// 这些可以在代码的任何地方被访问和调用
console.log(globalVar);       // 访问全局变量
globalFunction();             // 调用全局函数
```

### 注意事项

- 全局变量和函数应当慎用，因为它们可能会被脚本中的任何其他代码所改变，这会导致代码的脆弱性和可维护性降低。
- 避免全局污染的一个方法是使用立即执行函数表达式（IIFE）或者模块化的方法（如ES6的模块），来封装变量和函数，限制它们的作用域。

### 在浏览器中

在浏览器环境中，全局作用域通常是`window`对象，这意味着定义在全局作用域中的所有变量和函数都会作为`window`对象的属性和方法。

```javascript
var globalVar = "This is accessible as window.globalVar";
console.log(window.globalVar); // "This is accessible as window.globalVar"
```

### ECMAScript 6及以后

随着ES6的引入，`let`和`const`关键字允许开发者在块级作用域内声明变量，从而减少全局作用域的污染。然而，如果`let`和`const`在全局作用域中使用，它们声明的变量不会成为`window`对象的属性。

```javascript
let globalLet = "This is not on the window object";
console.log(window.globalLet); // undefined
```

这种行为有助于减少无意中的全局污染，因此在现代JavaScript开发中，推荐尽可能地使用`let`和`const`来代替`var`。

注意：

1. 为window对象动态添加的属性默认也是全局的，不推荐
2. 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！
3. 尽可能少的声明全局变量，防止全局变量被污染

### 作用域链

作用域链本质上是底层的**变量查找机制**。

- 在函数被执行时，会优先查找当前函数作用域中查找变量
- 如果当前作用域查找不到则会依次逐级查找父级作用域链直到全局作用域

总结：

1. 嵌套关系的作用域串联起来形成了作用域链
2. 相同作用域链中按着从小到大的规则查找变量
3. 子作用域能够访问父作用域，父级作用域无法访问子级作用域

在JavaScript中，作用域链是一个重要的概念，它定义了变量和函数的查找规则，即如何从当前执行的代码的作用域中查找变量和函数的值。

### 基础理解

每个JavaScript函数在创建的时候都会创建一个称为作用域（Scope）的东西，这个作用域是一个包含了所有局部变量的对象。当代码在一个环境中执行时，会创建一个称为执行上下文（Execution Context）的东西。

每个执行上下文有三个重要属性：

1. **变量对象（Variable Object）**：包含了环境中声明的所有变量和函数声明。
2. **作用域链（Scope Chain）**：确定当前上下文中代码访问变量的权限。它是由当前环境与上层环境的一系列变量对象组成的链。
3. **`this`值**: 在执行上下文中，this值取决函数的调用方式，可能是全局对象、函数自身、对象的实例等。。

### 作用域链的构建

当代码在一个函数中执行时，它需要访问变量。这些变量可能在当前函数内部声明，也可能在外部函数或全局作用域中声明。JavaScript引擎会首先搜索当前函数的变量对象，如果没有找到，它会继续在父级执行上下文的变量对象中查找，一直回溯到全局执行上下文。这样一层层链接起来的链条就是作用域链。

### 执行上下文的生命周期

执行上下文的生命周期可以分为两个阶段：

1. **创建阶段（Creation Phase）**：
   - 在代码执行之前，首先进入创建阶段。在这个阶段，JavaScript引擎会：
     - 创建变量对象。
     - 创建作用域链。
     - 确定`this`的值。

2. **执行阶段（Execution Phase）**：
   - 在这个阶段，具体的代码会被执行。这包括：
     - 赋值给变量。
     - 函数的调用。
     - 执行其他代码。

### 执行上下文栈

JavaScript引擎使用执行上下文栈（也称为调用栈）来管理执行上下文。当JavaScript代码开始执行时，全局执行上下文首先被推入栈中。每当发生函数调用时，一个新的执行上下文为该函数创建并推入栈顶。函数执行完毕后，其执行上下文从栈中弹出，控制权返回到当前栈顶的执行上下文。

### 查找过程

1. **局部作用域**：函数被调用时，首先会查找函数内部的局部变量。
2. **外层作用域**：如果没有找到，就会查找包含这个函数的外部函数的局部变量。
3. **全局作用域**：这个过程会一直持续到全局作用域。

### 代码示例

```javascript
let globalVar = 'global';

function outer() {
  let outerVar = 'outer';

  function inner() {
    let innerVar = 'inner';
    
    console.log(innerVar); // 'inner'
    console.log(outerVar); // 'outer'
    console.log(globalVar); // 'global'
  }
  
  inner();
}

outer();
```

在这个例子中，当`inner()`函数被调用时：

- 首先，在`inner()`函数的作用域中查找`innerVar`变量，找到后打印。
- 接着，查找`outerVar`变量，`inner()`没有声明它，因此会沿作用域链向上查找到`outer()`函数的作用域，找到后打印。
- 最后，查找`globalVar`变量，它也不在`inner()`和`outer()`函数内部声明，因此继续沿作用域链向上查找到全局作用域，找到后打印。

### 重要性

作用域链的概念是闭包（closure）的基础。闭包是一个函数和其被捕获的外部函数的变量对象的组合。

### 性能考虑

作用域链越长，查找变量所需要的时间就越多。在性能敏感的代码中，嵌套函数过多可能会影响到查找速度，因此建议尽量保持作用域链的简短，以优化代码性能。
