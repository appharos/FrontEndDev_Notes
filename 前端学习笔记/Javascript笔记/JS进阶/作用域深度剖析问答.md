# 深度剖析问答


## 如何很好的理解执行上下文是什么？
   
要理解执行上下文（Execution Context）在JavaScript中的作用和意义，我们首先需要明白JavaScript代码在运行时的基本机制。执行上下文是JavaScript代码被解析和执行时所在环境的一个抽象概念。

### 执行上下文的类型

在JavaScript中，主要有三种类型的执行上下文：

1. **全局执行上下文（Global Execution Context）**：
   - 这是最外层的执行上下文。在浏览器中，全局执行上下文相当于`window`对象，而在Node.js中，它代表全局对象。在任何JavaScript代码运行之前，会先创建一个全局执行上下文。

2. **函数执行上下文（Function Execution Context）**：
   - 每当一个函数被调用时，就会为该函数创建一个新的执行上下文。每个函数都有自己的执行上下文，即使是递归自己。

3. **评估执行上下文（Eval Execution Context）**：
   - 由`eval`函数产生的上下文，较少使用且通常不推荐。

### 执行上下文的组成

每个执行上下文都包含三个重要的组成部分：

1. **变量对象（Variable Object）**：
   - 包含函数的参数、内部变量和函数声明。

2. **作用域链（Scope Chain）**：
   - 确定当前上下文中代码访问变量的权限。它是由当前环境与上层环境的一系列变量对象组成的链。

3. **`this`值（Context）**：
   - 在执行上下文中，`this`值取决于函数的调用方式，可能是全局对象、函数自身、对象的实例等。

### 执行上下文的生命周期

执行上下文的生命周期可以分为两个阶段：

1. **创建阶段（Creation Phase）**：
   - 在代码执行之前，首先进入创建阶段。在这个阶段，JavaScript引擎会：
     - 创建变量对象。
     - 创建作用域链。
     - 确定`this`的值。

2. **执行阶段（Execution Phase）**：
   - 在这个阶段，具体的代码会被执行。这包括：
     - 赋值给变量。
     - 函数的调用。
     - 执行其他代码。

### 执行上下文栈

JavaScript引擎使用执行上下文栈（也称为调用栈）来管理执行上下文。当JavaScript代码开始执行时，全局执行上下文首先被推入栈中。每当发生函数调用时，一个新的执行上下文为该函数创建并推入栈顶。函数执行完毕后，其执行上下文从栈中弹出，控制权返回到当前栈顶的执行上下文。

### 总结

理解执行上下文是理解JavaScript工作原理的核心。它有助于理解变量的作用域、闭包的概念、`this`的行为以及代码执行顺序等关键概念。



## var关键字的变量声明是否会让变量的作用域变成全局作用域？

在JavaScript中，使用`var`关键字声明的变量具有函数作用域或全局作用域，这取决于它们声明的位置：

1. **全局作用域**：如果`var`关键字用于函数外部声明变量，那么该变量将具有全局作用域。这意味着它可以在代码的任何地方被访问和修改。

   ```javascript
   var globalVar = "I am global";

   function demoFunction() {
       console.log(globalVar); // 可以访问全局变量
   }

   demoFunction(); // 输出: I am global
   ```

2. **函数作用域**：如果`var`关键字用于函数内部声明变量，那么该变量将具有函数作用域。它只能在声明它的函数内部以及任何嵌套的函数内部被访问。

   ```javascript
   function demoFunction() {
       var localVar = "I am local";
       console.log(localVar); // 在函数内部访问
   }

   demoFunction(); // 输出: I am local
   console.log(localVar); // 错误：localVar 在此处不可访问
   ```

在ES6之前，JavaScript没有块级作用域（由`{}`定义的作用域），这意味着使用`var`声明的变量要么是全局的，要么是函数级的。这与`let`和`const`关键字（在ES6中引入）有所不同，后者支持块级作用域。

### 提升（Hoisting）

另一个需要考虑的重要概念是变量提升（Hoisting）。在JavaScript中，使用`var`声明的变量会被提升到其作用域的顶部，但只提升声明，不提升赋值。这意味着你可以在声明变量之前引用它，但是直到执行到声明语句之后，变量的值才会被确定。

```javascript
console.log(hoistedVar); // 输出：undefined（不是ReferenceError）
var hoistedVar = "I am hoisted";
```

在这个例子中，`hoistedVar`被提升，但它的值在`console.log`执行时还是`undefined`。

总之，使用`var`声明的变量的作用域取决于它们的声明位置。在函数外声明的变量是全局的，在函数内声明的变量是局部的。同时，由于变量提升，`var`的行为可能会导致一些不直观的结果。



## 块级作用域跟函数作用域有什么区别？

块级作用域和函数作用域是JavaScript中两种不同的变量作用域类型，它们定义了变量在何处以及如何可以被访问。以下是它们之间的主要区别：

### 函数作用域

1. **定义**：函数作用域是指在函数内部声明的变量。这些变量只能在函数内部访问和使用。
2. **范围**：仅限于函数内部，包括函数内部的嵌套块和子函数。
3. **关键字**：通常使用`var`关键字（ES5及之前）声明函数作用域的变量。
4. **生命周期**：当函数执行时，这些变量被创建；函数执行完毕后，这些变量被销毁。
5. **提升（Hoisting）**：`var`声明的变量会提升到函数的顶部，但只提升声明不提升赋值。

### 块级作用域

1. **定义**：块级作用域是由一对大括号`{}`（如`if`语句、`for`循环等）包围的区域。在这个区域内声明的变量，只在这个区域内有效。
2. **范围**：限于大括号`{}`内部，不包括外部或包含该块的函数。
3. **关键字**：使用`let`和`const`（自ES6起）声明块级作用域的变量。
4. **生命周期**：这些变量在代码块执行时被创建，在代码块执行完毕后被销毁。
5. **提升**：`let`和`const`声明的变量也会提升到块的顶部，但不会初始化，访问它们会产生“暂时性死区”直到它们的声明被执行。

### 示例

以下示例展示了函数作用域和块级作用域的区别：

```javascript
function funcScopeExample() {
    if (true) {
        var funcVar = "Visible in the entire function";
        let blockVar = "Visible only in this block";
    }
    console.log(funcVar);   // 输出: Visible in the entire function
    console.log(blockVar);  // 报错: blockVar is not defined
}

funcScopeExample();
```

在这个示例中，`funcVar`具有函数作用域，可以在整个`funcScopeExample`函数中访问。而`blockVar`具有块级作用域，仅在其声明的`if`块内部可见。

### 结论

- 函数作用域主要用于限制变量的生命周期到整个函数内部。
- 块级作用域用于更细粒度地限制变量的生命周期到特定的代码块内部。
- 在ES6之后，建议使用`let`和`const`来创建块级作用域变量，以获得更好的控制和避免潜在的作用域相关问题。


## 什么是暂时性死区?

在JavaScript中，暂时性死区（Temporal Dead Zone，TDZ）是一个术语，用于描述在代码块中使用`let`和`const`声明变量时，从块开始到变量声明之间的区域。在这个区域内，这些变量被绑定（存在），但还没有被初始化（赋值），因此访问它们会导致引用错误。

### 暂时性死区的特点

1. **不可访问**：在变量声明之前，尝试访问用`let`或`const`声明的变量会抛出一个引用错误。
2. **阻止提升**：虽然`var`声明的变量会提升到函数或全局作用域的顶部，但`let`和`const`声明的变量不会提升到代码块的顶部。
3. **块级作用域**：TDZ是块级作用域的一个组成部分，它确保了变量在声明前不可被访问。

### 示例

以下是暂时性死区的一个例子：

```javascript
function example() {
    // TDZ开始
    console.log(myVar);    // ReferenceError: myVar is not defined
    console.log(myLet);    // ReferenceError: Cannot access 'myLet' before initialization
    console.log(myConst);  // ReferenceError: Cannot access 'myConst' before initialization

    var myVar = "var变量"; // var声明的变量提升
    let myLet = "let变量"; // let声明的变量在TDZ内
    const myConst = "const常量"; // const声明的变量在TDZ内
    // TDZ结束

    console.log(myVar);    // 输出: var变量
    console.log(myLet);    // 输出: let变量
    console.log(myConst);  // 输出: const常量
}

example();
```

在这个例子中，在声明`myLet`和`myConst`之前尝试访问它们会抛出错误，因为它们处于TDZ内。而`var`声明的变量`myVar`由于提升，它在声明之前是`undefined`而不是抛出错误。

### 暂时性死区的意义

暂时性死区的主要目的是为了使变量的使用更加安全和可预测。它避免了在变量声明前不小心使用变量的情况，这有助于避免难以发现的错误，提高了代码的可维护性。通过确保变量在声明之前不能被访问，TDZ有助于减少因变量提升引起的错误和混淆。