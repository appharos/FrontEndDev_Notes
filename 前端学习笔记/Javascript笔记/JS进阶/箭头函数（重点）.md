## 箭头函数（重要）


目的：引入箭头函数的目的是更简短的函数写法并且不绑定this, 箭头函数的语法比函数表达式更简洁

使用场景： 箭头函数更适用于那些本来需要匿名函数的地方




箭头函数（Arrow function）是ES6中引入的一种更简洁的函数写法。它不仅语法简洁，而且共享了所在上下文的 `this` 值，这一点与传统的函数（如函数表达式或函数声明）有所不同。

### 基本语法

箭头函数的基本语法如下：

```javascript
// 无参数
() => { /* 函数体 */ }

// 单个参数，可以省略括号
x => { /* 函数体 */ }

// 多个参数
(x, y) => { /* 函数体 */ }

// 如果函数体只有一行返回语句，可以省略大括号和return
x => x * x

// 返回对象字面量时，需要用括号包围对象
x => ({ value: x })

const fn1 = uname => ({uname: uname})
console.log(fn1('作为对象传递进形参'))
```


### 箭头函数的this指向

简要概括：箭头函数不会创建自己的this,他只会从自己的作用域链的上一层沿用this。
在开发中【使用箭头函数前需要考虑函数中this的值】，事情回调函数使用箭头函数时，this为全局的window，因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。



箭头函数（Arrow Function）是 ES6 中引入的新的函数语法。它们有几个特点，但最显著的是它们对 `this` 关键字的处理。在箭头函数中，`this` 的值不是由函数被调用的方式决定的，而是由函数在哪里被创建决定的。这个特性被称为“词法作用域”或“静态作用域”。

### 箭头函数中的 `this`

1. **词法作用域**：箭头函数不创建自己的 `this` 上下文，因此它的 `this` 值与外围（词法层面的）执行上下文的 `this` 一致。这个特性在需要使用 `this` 的回调函数中非常有用。

2. **没有绑定 `this`**：因为箭头函数不绑定自己的 `this`，所以 `call()`、`apply()`、`bind()` 这些方法只能传递参数，但不会改变 `this` 的值。

3. **适用场景**：箭头函数最适合用于那些不需要自己的 `this` 上下文的场景，如回调函数、定时器、数组方法等。

### 示例

#### 在对象方法中

当箭头函数用作对象方法时，需要注意 `this` 的值可能不是预期的对象。

```javascript
const myObject = {
  myMethod: () => {
    return this; // 这里的 this 不是 myObject
  }
};

myObject.myMethod(); // 不是 myObject，而是定义 myMethod 时的外层 this
```

#### 在事件监听器中

箭头函数保留了定义它时的 `this` 值。

```javascript
class Button {
  constructor() {
    this.label = 'My Button';
    document.getElementById('myButton').addEventListener('click', () => {
      console.log(this.label); // 'My Button'
    });
  }
}
```

#### 作为数组方法的回调

箭头函数在数组方法（如 `map`、`filter`、`forEach` 等）的回调中非常有用，因为它们可以继承外部上下文的 `this`。

```javascript
const numbers = [1, 2, 3];
const increment = numbers.map((number) => number + 1); // [2, 3, 4]
```

### 注意事项

- 箭头函数不能用作构造函数，使用 `new` 关键字调用会抛出错误。
- 箭头函数没有自己的 `arguments` 对象，但可以使用剩余参数（`...args`）代替。
- 在需要动态上下文的场合（如对象方法、原型方法、构造函数等）应避免使用箭头函数。

总结来说，箭头函数提供了一种更简洁的函数书写方式，并且通过词法作用域简化了 `this` 的行为，使得在回调和函数式编程场景中更加方便。然而，它们并不适合所有情况，特别是在需要动态上下文的场景中。





### 特点

1. **没有自己的 `this`、`arguments`、`super` 或 `new.target`**: 这些值由外围最近一层非箭头函数决定。
   
2. **不能用作构造函数**: 不能使用 `new` 关键字调用箭头函数，因为箭头函数没有自己的 `this`，也没有 `prototype` 属性。

3. **没有原型属性**: 箭头函数没有 `prototype` 属性。

4. **无法更改 `this` 的绑定**: 箭头函数内的 `this` 值在创建时确定，之后无法更改。

5. **简洁的语法**: 比传统的函数表达式更简洁。

6. **隐式返回**: 如果箭头函数只包含一个表达式，它将隐式返回这个表达式的值，不需要使用 `return` 语句。如果需要返回一个对象字面量，则需要用括号将对象包围起来。



### 示例

**无参数箭头函数**:

```javascript
let greet = () => console.log("Hello World!");
greet(); // 输出: Hello World!
```

**带参数的箭头函数**:

```javascript
let square = x => x * x;
console.log(square(4)); // 输出: 16
```

**对象字面量返回**:

```javascript
let getObject = () => ({ name: "Alice", age: 25 });
console.log(getObject()); // 输出: { name: "Alice", age: 25 }
```

**更高级的例子**:

```javascript
// 箭头函数作为回调
[1, 2, 3].map(x => x * x); // 返回 [1, 4, 9]

// 立即执行的箭头函数
let person = ((name) => ({ getName: () => name }))("Alice");
console.log(person.getName()); // 输出: Alice
```

### 使用场景

箭头函数特别适合用在那些需要匿名函数的地方，比如回调函数。由于它们可以捕获外部 `this` 值，箭头函数在处理 `this` 时通常比传统函数更方便，特别是在你希望 `this` 保持一致时。例如，在事件处理器、定时器或者当你使用函数式编程模式时。

### 注意事项

虽然箭头函数在许多情况下都很有用，但它们并不适合所有场景。比如，当你需要一个具有动态 `this` 值的函数，或者你需要一个构造函数时，应该使用传统的函数表达式或函数声明。