## 深入对象

## 创建对象三种方式

1. 利用对象自变量创建对象

```js
const o = {
    name: '佩奇'
}
```

2. 利用new Object创建对象

```js
const o = new Object({name: '佩奇'})
console.log(o) // {name: '佩奇'}
```

3. 利用构造函数创建对象

- 构造函数：是一种特殊的函数，主要用来初始化对象
- 使用场景：常规的{...}语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一遍，此时可以通过构造函数来快速创建多个类似的对象。
- 构造函数在技术上是常规函数。但有两个约定：1.  函数首字母大写  2. 使用new 关键字调用

说明：

1. 使用new关键字调用函数的行为被称为实例化
2. 实例化构造函数时没有参数时可以省略（）
3. 构造函数内部无需写return, 返回值即为新创建的对象
4. 构造函数内部的return返回的值无效，所以不要写return
5. new Object(), new Date()也是实例化构造函数

GPT解释：

构造函数是在JavaScript中用来创建特定类型对象的一种特殊函数。使用构造函数创建对象的过程类似于在其他编程语言（如Java或C++）中的对象实例化。构造函数在JavaScript中用于创建具有相同属性和方法的多个对象。

### 基本概念

- **构造函数通常首字母大写**：这是一个约定，用以区分普通函数和构造函数。
- **使用`new`关键字调用**：创建对象时，需要使用`new`关键字来调用构造函数。
- **`this`关键字的使用**：在构造函数内部，`this`关键字引用了将要被创建的新对象。

### 示例

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
        console.log('Hello, my name is ' + this.name);
    };
}

// 使用构造函数创建两个不同的对象
let person1 = new Person('Alice', 25);
let person2 = new Person('Bob', 30);

person1.greet(); // 输出: Hello, my name is Alice
person2.greet(); // 输出: Hello, my name is Bob
```

### 构造函数的工作原理

当使用`new`关键字调用函数时，JavaScript会执行以下步骤：

1. **创建一个新的空对象**：JavaScript首先创建一个空的对象。
2. **设置原型链**：新对象的原型被设置为构造函数的`prototype`属性。
3. **将`this`绑定到新对象**：在构造函数内部，`this`关键字引用新创建的对象。
4. **执行构造函数中的代码**：构造函数内的代码被执行，通常这些代码会初始化新对象的属性。
5. **返回新对象**：如果构造函数没有返回其他对象，则返回这个新创建的对象。

### 使用构造函数的优点

- **代码重用**：可以多次调用同一个构造函数来创建新对象，从而实现代码重用。
- **清晰的对象类型定义**：构造函数可以清晰地定义对象的类型和结构，易于理解和维护。

### 注意事项

- **不要忘记使用`new`关键字**：如果忘记使用`new`，`this`将指向全局对象（在浏览器中是`window`），这可能会导致意外的全局变量污染。
- **构造函数内部的方法**：每次使用构造函数创建对象时，对象内的方法也会被重新创建。为了避免这种情况，通常将方法定义在构造函数的`prototype`属性上。

### 使用`prototype`属性

将方法添加到构造函数的`prototype`属性上，可以使所有实例共享同一个方法，而不是在每个实例中重新创建该方法。

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log('Hello, my name is ' + this.name);
};

let person1 = new Person('Alice', 25);
let person2 = new Person('Bob', 30);

person1.greet(); // 输出: Hello, my name is Alice
person2.greet(); // 输出: Hello, my name is Bob
```

在这个例子中，`greet`方法只被创建一次，并被`person1`和`person2`共享。

## 实例化执行过程

实例化是面向对象编程中的一个核心概念，它涉及到创建一个类的具体实例。在JavaScript中，这通常是通过使用构造函数和`new`关键字来完成的。以下是实例化过程的详细步骤：

### 实例化的步骤

1. **创建一个新对象**：
   当使用`new`关键字调用一个构造函数时，JavaScript首先创建一个新的空对象。

2. **设置原型**：
   新对象的原型（`__proto__`属性）被设置为构造函数的`prototype`属性。这意味着新对象将继承构造函数原型上的所有方法和属性。

3. **绑定`this`关键字**：
   在构造函数内部，`this`关键字被绑定到新创建的对象上。这使得可以在构造函数内部为新对象添加属性和方法。

4. **执行构造函数内的代码**：
   构造函数内部的代码随后被执行。通常，这些代码会根据传入的参数初始化新对象的属性。

5. **返回新对象**：
   除非构造函数显式返回另一个对象，否则这个新创建的对象会在构 造函数调用结束后被返回。

### 示例

假设有一个`Person`构造函数，下面的例子展示了实例化过程：

```javascript
function Person(name, age) {
    // 步骤3：此时 this 指向新创建的对象
    this.name = name; // 添加属性到 this 引用的对象上
    this.age = age;
    // 步骤4：可以执行更多的初始化代码
}

// 步骤1、2和5：创建Person的一个新实例
let person = new Person('Alice', 25);
```

在上面的代码中，当`new Person('Alice', 25)`被调用时，一个新的对象被创建（步骤1和2），`this`关键字在`Person`函数体内指向这个新对象（步骤3），`Person`函数内的代码执行，给新对象添加`name`和`age`属性（步骤4）。最后，这个新创建并初始化的对象被返回并赋值给变量`person`（步骤5）。

### 注意事项

- **构造函数命名**：按照惯例，构造函数的名称应该以大写字母开头。
- **`new`关键字的重要性**：如果忘记使用`new`关键字调用构造函数，`this`将指向全局对象（在浏览器中是`window`），这可能导致意外的结果，比如创建全局变量。
- **共享方法**：为了节省内存，通常将方法添加到构造函数的`prototype`属性上，而不是在构造函数内部定义。

通过这个过程，JavaScript的构造函数提供了一种机制来创建具有特定属性和方法的对象，支持代码的重用和封装。

## 实例成员和静态成员

1. 实例成员：通过构建函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员（实例属性和实例方法）

说明：

1) 为构造函数传入参数，创建结构相同但值不同的对象
2) 构造函数创建的实例对象 彼此独立互不影响

2. 静态成员：构造函数的属性和方法被称为静态成员（静态属性和方法）

说明：

1. 静态成员只能构造函数来访问
2. 静态方法中的this指向构造函数

在 JavaScript 中，构造函数用于创建特定类型的对象。当构造函数用于创建对象时，它定义了这些对象的属性和行为。构造函数的实例成员和静态成员是这些定义的两个主要部分。

### 实例成员

实例成员是那些在构造函数的每个实例上定义的属性和方法。这些成员是每个对象实例特有的，不会在构造函数的不同实例之间共享。当你通过 `new` 关键字创建一个新对象时，每个对象都会有自己的一套实例成员的副本。

#### 示例

```javascript
function Person(name, age) {
    // 实例属性
    this.name = name;
    this.age = age;

    // 实例方法
    this.describe = function() {
        return `${this.name} is ${this.age} years old.`;
    };
}

// 创建实例
const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

console.log(person1.describe()); // Alice is 25 years old.
console.log(person2.describe()); // Bob is 30 years old.
```

在此示例中，`name` 和 `age` 属性以及 `describe` 方法是 `Person` 的实例成员。

### 静态成员

静态成员是直接定义在构造函数本身上的属性和方法，而不是定义在实例对象上。静态成员通常用于那些与特定对象实例无关的功能。在 JavaScript 中，静态成员可以通过在构造函数上直接定义来创建。

#### 示例

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// 静态属性
Person.species = "Homo sapiens";

// 静态方法
Person.compareAge = function(person1, person2) {
    return person1.age - person2.age;
};

const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

console.log(Person.species); // Homo sapiens
console.log(Person.compareAge(person1, person2)); // -5
```

在这个例子中，`species` 和 `compareAge` 是 `Person` 的静态成员。请注意，这些静态成员是直接通过 `Person` 构造函数访问的，而不是通过 `Person` 的实例（如 `person1` 或 `person2`）访问的。

### 总结

- **实例成员**是每个对象实例特有的属性和方法。
- **静态成员**是定义在构造函数本身上的属性和方法，与对象实例无关，由所有实例共享。

了解这两种成员的区别对于理解 JavaScript 中对象的行为和构造函数的使用非常重要。
