# 浮动 

视觉格式化模型，大体上将页面中盒子的排列分为三种方式：

1. 常规流
2. 浮动
3. 定位


# 应用场景

1. 文字环绕
2. 横向排列


## 浮动的基本特点

修改float属性值为：

- left: 左浮动，元素靠上靠左
- right: 右浮动，元素靠上靠右

默认值为none

1. 当一个元素浮动后，元素必定为块盒(更改display属性为block)
2. 浮动元素的包含块，和常规流一样，为父元素的内容盒。


## 盒子尺寸

1. 宽度为auto时，适应内容宽度
2. 高度为auto时，与常规流一致，适应内容的高度
3. margin为auto,为0
4. 边框、内边距、百分比设置与常规流一样

# 盒子排列

1. 左浮动的盒子靠上靠左排列
2. 右浮动的盒子靠上靠右排列
3. 浮动盒子在包含块中排列时，会避开常规流块盒
4. 常规流块盒在排列时，无视浮动盒子
5. 行盒在排列时，会自动避开浮动盒子

> 如果文字没有在行盒中，浏览器会自动生成一个行盒包裹文字，该行盒叫做匿名行盒。

想要改变文字离图片的距离可以，得使用图片的margin设置，因为p元素的margin会无视图片


## 高度坍塌

高度坍塌的根源： 常规流盒子的自动高度，在计算时，不会考虑浮动的盒子

清除浮动，涉及css属性:clear

- 默认值：none
- left:清除左浮动，该元素必须出现在前面所有左浮动盒子的下方
- right: 清除右浮动，该元素必须出现在前面所有右浮动盒子的下方
- both：清除左右浮动，该元素必须出现在前面所有浮动盒子的下方
   

> chatgpt解释：

在CSS布局中，"高度坍塌"（height collapse）是一个常见的现象，它通常发生在块级元素与浮动元素（元素使用了 `float` 属性）共享同一个父元素时。

在高度坍塌的情况下，如果父元素的高度是由其子元素的高度决定的（即，父元素没有明确的高度设置），并且所有或者部分子元素都设置了浮动，那么父元素的高度就会“坍塌”到浮动元素之外，看起来就像父元素没有足够的高度来包含其浮动的子元素。

这是一个例子：

```html
<div style="border: 1px solid red;">
  <div style="float: left; width: 100px; height: 100px; border: 1px solid blue;"></div>
</div>
```

在这个例子中，父元素（红色边框）的高度实际上是0，因为它的子元素是浮动的，所以它的高度被坍塌了。尽管子元素（蓝色边框）的高度是100像素，但父元素并没有扩展到足够的高度来包含它。

为了解决这个问题，通常会使用一种称为“清除浮动”（clearing floats）的技巧。最常见的方法是在父元素中添加一个新的子元素，并设置其 `clear` 属性为 `both`。这将会“清除”之前的浮动，使父元素的高度正确地包含其所有子元素。其他的解决方法包括使用 CSS 的 `overflow` 属性或者使用伪元素（`:after`）来清除浮动。


**clear属性解决高度坍塌**
在CSS中，`clear`属性用于控制元素是否允许在其左侧、右侧或者两侧有浮动元素。

浮动元素会从正常的文档流中移出，然后向其父元素的左侧或者右侧移动，直到它的外边距接触到另一个元素的边框、内边距或者外边距，或者达到其包含块的边缘。

`clear`属性有以下几个值：

- `none`：默认值，元素允许有浮动元素在其两侧。
- `left`：元素不允许有浮动元素在其左侧。
- `right`：元素不允许有浮动元素在其右侧。
- `both`：元素不允许有浮动元素在其两侧。

这是一个例子：

```html
<div style="float: left; width: 100px; height: 100px; background: red;"></div>
<div style="clear: left; width: 100px; height: 100px; background: blue;"></div>
```

在这个例子中，红色的`div`是浮动的，而蓝色的`div`设置了`clear: left`，这使得蓝色的`div`不会出现在红色`div`的左侧，即使这意味着蓝色的`div`需要移到下一行。


**使用after伪元素解决高度坍塌**

在CSS中，`:after`是一个伪元素，它可以用来插入一些内容到元素的内容之后。这个生成的内容被视为元素的最后一个子元素。

`:after`伪元素常常和`content`属性一起使用，`content`属性用来指定要插入的内容。如果`content`属性的值是一个空字符串，那么就不会插入任何内容，但`:after`伪元素仍然会被创建。

你可以用`:after`伪元素和`clear`属性来清除浮动，这是一种非常常用的技巧。以下是一个例子：

```css
/* 单独为解决高度坍塌设置一个clearfix类， 加在一些元素里 */
.clearfix ::after {   
  content: "";
  display: table; 
  /* 也可以写成display: block     */
  clear: both;
}
```

在这个例子中，`::after`伪元素被添加到了类名为`.container`的所有元素的内容之后。伪元素的`content`属性被设置为一个空字符串，所以不会插入任何内容。然后，`display`属性被设置为`table`，这样伪元素就会表现得像一个块级元素，并且`clear`属性被设置为`both`，这样就会清除之前的所有浮动。

通过这种方式，你可以确保`.container`元素的高度正确地包含了所有的浮动子元素，而不会发生高度坍塌。