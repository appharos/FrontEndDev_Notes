# pager组件

<img src="http://mdrs.yuanjin.tech/img/20201113130301.png" style="zoom:50%;" />

## 属性

| 属性名        | 含义       | 类型   | 必填 | 默认值 |
| ------------- | ---------- | ------ | ---- | ------ |
| current       | 当前页码   | Number | 否   | 1      |
| total         | 总数据量   | Number | 否   | 0      |
| limit         | 页容量     | Number | 否   | 10     |
| visibleNumber | 可见页码数 | Number | 否   | 10     |

## 事件

| 事件名     | 含义     | 事件参数 | 参数类型 |
| ---------- | -------- | -------- | -------- |
| pageChange | 页码变化 | 新的页码 | Number   |

# 知识点

1. **全局样式**

2. **v-if 和 v-show**

GPT解释：

在 Vue 2 中，`v-if` 和 `v-show` 是两个用于根据条件渲染元素的指令，但它们之间有一些关键的区别：

### v-if

- `v-if` 指令用于根据表达式的真假值条件性地渲染元素。如果表达式的值为真（truthy），则元素会被渲染到 DOM 中；如果值为假（falsy），则元素不会被渲染。
- 当条件变为假时，元素及其子元素会被销毁和移除，当条件再次变为真时，元素会重新创建和渲染。
- `v-if` 是“真正”的条件渲染，因为它确保在切换时条件块内的事件监听器和子组件适当地被销毁和重建。
- `v-if` 也可以和 `v-else` 或 `v-else-if` 一起使用，提供多个条件分支。

### v-show

- `v-show` 指令也是基于表达式的真假值来显示或隐藏元素，但与 `v-if` 不同的是，即使表达式为假，元素也会被渲染到 DOM 中，只是 CSS 的 `display` 属性会被设置为 `none`。
- 由于 `v-show` 只是切换元素的显示状态，元素始终保留在 DOM 中。因此，相较于 `v-if`，`v-show` 的初始渲染成本更低，但切换成本更高（因为涉及到 CSS 属性的变化）。
- `v-show` 不支持 `v-else` 或 `v-else-if` 分支。

### 使用场景

- **`v-if`** 更适合于条件不经常改变的场景，因为它在切换条件时有更高的初始渲染成本。由于它会导致 DOM 元素的创建和销毁，频繁切换可能会导致性能问题。
- **`v-show`** 更适合于需要频繁切换的条件，因为元素始终被渲染，只是简单地切换显示状态。它的初始渲染成本较低，但保持了元素和其绑定的事件或子组件状态。

### 示例

```html
<!-- v-if -->
<div v-if="isVisible">看到我了！</div>

<!-- v-else-if -->
<div v-else-if="isAnotherCondition">现在看到我了！</div>

<!-- v-else -->
<div v-else>现在看不到我！</div>

<!-- v-show -->
<div v-show="isVisible">我一直在 DOM 中，只是可能看不到我！</div>
```

在实际应用中，选择 `v-if` 还是 `v-show` 取决于具体场景和性能考虑。

   **面试题：v-if 和 v-show 有什么区别？**

   ```
   v-if能够控制是否生成vnode，也就间接控制了是否生成对应的dom。当v-if为true时，会生成对应的vnode，并生成对应的dom元素；当其为false时，不会生成对应的vnode，自然不会生成任何的dom元素。
   v-show始终会生成vnode，也就间接导致了始终生成dom。它只是控制dom的display属性，当v-show为true时，不做任何处理；当其为false时，生成的dom的display属性为none。
   使用v-if可以有效的减少树的节点和渲染量，但也会导致树的不稳定；而使用v-show可以保持树的稳定，但不能减少树的节点和渲染量。
   因此，在实际开发中，显示状态变化频繁的情况下应该使用v-show，以保持树的稳定；显示状态变化较少时应该使用v-if，以减少树的节点和渲染量。
   ```

3. **组件事件**

   抛出事件：子组件在某个时候发生了一件事，但自身无法处理，于是通过事件的方式通知父组件处理

   事件参数：子组件抛出事件时，传递给父组件的数据

   注册事件：父组件申明，当子组件发生某件事的时候，自身将做出一些处理

GPT解释：
在 Vue.js 中，组件间的通信可以通过事件实现，尤其是对于父子组件之间的交互。这种方式类似于原生 DOM 事件，但在 Vue 组件体系内部使用。下面是关于 Vue 组件事件的一些关键点：

### 1. 发射事件（Emitting Events）

子组件可以使用 `$emit` 方法发射事件，父组件可以监听这些事件。当子组件需要通知父组件某些动作或状态变化时，它会发射一个事件。父组件监听到这个事件后，可以执行相应的响应操作。

**子组件**：

```vue
<template>
  <button @click="handleClick">Click me</button>
</template>

<script>
export default {
  methods: {
    handleClick() {
      // 发射一个名为 'my-event' 的事件，可以携带数据作为第二个参数
      this.$emit('my-event', 'some data');
    }
  }
}
</script>
```

**父组件**：

```vue
<template>
  <!-- 监听子组件发射的事件，并定义响应方法 -->
  <child-component @my-event="handleEvent"></child-component>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: {
    ChildComponent
  },
  methods: {
    handleEvent(data) {
      console.log('Event received:', data);
    }
  }
}
</script>
```

### 2. 监听子组件事件

父组件可以通过在子组件的标签上使用 `v-on`（或简写为 `@`）监听子组件发射的事件。当事件被发射时，父组件中绑定的方法将被调用。

### 3. `.native` 修饰符

在 Vue 2 中，如果你需要在父组件中监听子组件根元素的原生事件（而不是组件自定义的事件），你需要使用 `.native` 修饰符。但在 Vue 3 中，这一概念已经被移除，取而代之的是其他方式（如使用 `v-on` 的对象语法）。

```vue
<template>
  <!-- 在 Vue 2 中 -->
  <child-component @click.native="nativeClickHandler"></child-component>
</template>
```

### 4. 事件传递

有时候，子组件需要将接收到的事件再传递给它的父组件。这可以通过在子组件内监听一个事件然后立即发射另一个事件来实现，但更常见的做法是直接在模板中绑定父组件的方法。

### 5. 事件解绑

如果你动态地添加了事件监听器，那么也应该注意在组件销毁时移除它们。不过，如果你是通过模板声明的方式绑定事件（如上面的例子），Vue 会自动帮你管理事件的绑定和解绑，所以通常你不需要手动进行清理。

### 总结

组件事件是 Vue 中组件间通信的重要方式之一。正确使用事件可以让父子组件之间的数据传递和状态同步变得简单而清晰。在设计组件时，合理定义事件接口对于提高组件的可用性和灵活性至关重要。
