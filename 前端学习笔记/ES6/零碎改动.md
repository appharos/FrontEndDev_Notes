## 严格模式

JavaScript 的 "严格模式"（strict mode）是一种选择性地采用的更加严格的JavaScript语法。在严格模式下，JavaScript 会对错误更加严格，某些安全性问题或者效率低下的操作会被当做错误处理。这有助于捕捉一些常见的编程错误，防止变量泄漏，使得代码更容易被调试。

要启用严格模式，在脚本或函数的顶部添加 `"use strict";` 声明。这个声明看起来像一个字符串，但实际上是一个字面量表达式，不会被赋值给任何变量。

严格模式的一些主要特性包括：

1. **禁止使用未声明的变量：** 在严格模式下，赋值给未声明的变量会导致运行时错误，这有助于避免全局变量的不小心创建。

2. **禁止使用 `with` 语句：** `with` 语句不能用于严格模式，因为它可能导致代码难以优化和理解。

3. **限制函数内部的 `this` 关键字：** 在严格模式的函数内部，`this` 不会指向全局对象（在浏览器中是 `window`）。如果没有明确设置 `this`，它将是 `undefined`。

4. **禁止删除变量：** 在严格模式下，删除变量、函数或函数参数会抛出错误。

5. **错误处理更加严格：** 某些通常被忽略的错误（例如，对只读属性的赋值）会在严格模式下抛出异常。

6. **禁止重复参数：** 函数参数不能有相同的名称。

7. **更安全的 `eval`：** 在严格模式下，`eval` 函数有自己的作用域，不能用于在其包含作用域内创建变量。

8. **禁止八进制字面量：** 八进制字面量（如 `0123`）在严格模式下是禁止的。

通过使用严格模式，开发者能够写出更加健壮、可读性更强的代码。对于新的JavaScript项目，推荐始终使用严格模式。

## 使用立即执行函数（IIFE）解决var的一些问题

问题：

```js
var i;
for (i = 0; i < 10; i++){
    setTimeout(() => {
        console.log(i);
    },1000)
}
```

为什么这输出的是10个10?

GPT解释：

您的代码段中遇到的问题是由于 JavaScript 的闭包和异步执行机制造成的。

在循环中，`setTimeout` 函数被调用了 10 次，每次都计划在 1000 毫秒后执行一个函数。这个函数打印变量 `i` 的值。但是，由于 `setTimeout` 是异步的，循环不会等待 `setTimeout` 内的代码执行，而是继续执行，直到 `i` 变为 10 后停止。

此时，当每个 `setTimeout` 内的函数最终执行时，它们引用的 `i` 变量已经是循环结束后的值，即 10。因此，每个定时器最终都打印出 10。

这种行为是由 JavaScript 中变量作用域和闭包的工作方式决定的。在循环中使用 `setTimeout` 时，每个定时器的回调函数都捕获了同一个 `i` 变量的引用。

为了使每个定时器打印出其对应的循环索引值，您可以使用立即执行的函数表达式（IIFE）来捕获每次迭代的 `i` 的值，如下所示：

```javascript
for (var i = 0; i < 10; i++) {
    (function(i) {
        setTimeout(() => {
            console.log(i);
        }, 1000);
    })(i);
}
```

在这个修正后的代码中，IIFE 为每个循环迭代创建了一个新的作用域，确保 `setTimeout` 的回调函数引用的 `i` 的值是循环中该次迭代的值。因此，每个定时器将按预期打印 0 到 9 的值。
